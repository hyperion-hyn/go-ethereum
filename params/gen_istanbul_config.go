// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package params

import (
	"encoding/json"
	"errors"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/staking"
)

var _ = (*istanbulConfigMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (i IstanbulConfig) MarshalJSON() ([]byte, error) {
	type IstanbulConfig struct {
		Epoch          uint64                                           `json:"epoch"`
		ProposerPolicy uint64                                           `json:"policy"`
		Ceil2Nby3Block *big.Int                                         `json:"ceil2Nby3Block,omitempty"`
		Validators     map[common.UnprefixedAddress]staking.Delegations `json:"validators" gencodec:"required"`
	}
	var enc IstanbulConfig
	enc.Epoch = i.Epoch
	enc.ProposerPolicy = i.ProposerPolicy
	enc.Ceil2Nby3Block = i.Ceil2Nby3Block
	if i.Validators != nil {
		enc.Validators = make(map[common.UnprefixedAddress]staking.Delegations, len(i.Validators))
		for k, v := range i.Validators {
			enc.Validators[common.UnprefixedAddress(k)] = v
		}
	}
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (i *IstanbulConfig) UnmarshalJSON(input []byte) error {
	type IstanbulConfig struct {
		Epoch          *uint64                                          `json:"epoch"`
		ProposerPolicy *uint64                                          `json:"policy"`
		Ceil2Nby3Block *big.Int                                         `json:"ceil2Nby3Block,omitempty"`
		Validators     map[common.UnprefixedAddress]staking.Delegations `json:"validators" gencodec:"required"`
	}
	var dec IstanbulConfig
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Epoch != nil {
		i.Epoch = *dec.Epoch
	}
	if dec.ProposerPolicy != nil {
		i.ProposerPolicy = *dec.ProposerPolicy
	}
	if dec.Ceil2Nby3Block != nil {
		i.Ceil2Nby3Block = dec.Ceil2Nby3Block
	}
	if dec.Validators == nil {
		return errors.New("missing required field 'validators' for IstanbulConfig")
	}
	i.Validators = make(map[common.Address]staking.Delegations, len(dec.Validators))
	for k, v := range dec.Validators {
		i.Validators[common.Address(k)] = v
	}
	return nil
}
